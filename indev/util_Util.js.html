<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>util/Util.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="/index.html">Stable</a><a href="/indev/index.html">Indev</a></h2><h3>Pages</h3><ul><li><a href="tutorial-LocalizationGuide.html">Localization Guide</a></li><li><a href="tutorial-LocalizationHelptext.html">Localizing Command helptext</a></li><li><a href="tutorial-LocalizationStrings.html">Localization string list</a></li><li><a href="tutorial-PluginAuthoring.html">Plugin Authoring Guide</a></li><li><a href="tutorial-PluginList.html">Plugin list</a></li><li><a href="tutorial-StartingInV3.html">Starting a bot in 3.0.0</a></li></ul><h3>Classes</h3><ul><li><a href="Client.html">Client</a></li><li><a href="ClientStorage.html">ClientStorage</a></li><li><a href="Command.html">Command</a></li><li><a href="CommandLock.html">CommandLock</a></li><li><a href="CommandRegistry.html">CommandRegistry</a></li><li><a href="CompactModeHelper.html">CompactModeHelper</a></li><li><a href="Database.html">Database</a></li><li><a href="Event.html">Event</a></li><li><a href="EventLoader.html">EventLoader</a></li><li><a href="GuildSettings.html">GuildSettings</a></li><li><a href="GuildStorage.html">GuildStorage</a></li><li><a href="KeyedStorage.html">KeyedStorage</a></li><li><a href="Logger.html">Logger</a></li><li><a href="Plugin.html">Plugin</a></li><li><a href="PluginLoader.html">PluginLoader</a></li><li><a href="RateLimit.html">RateLimit</a></li><li><a href="RateLimiter.html">RateLimiter</a></li><li><a href="RateLimitManager.html">RateLimitManager</a></li><li><a href="Resolver.html">Resolver</a></li><li><a href="ResolverLoader.html">ResolverLoader</a></li><li><a href="SharedProviderStorage.html">SharedProviderStorage</a></li><li><a href="SingleProviderStorage.html">SingleProviderStorage</a></li><li><a href="StorageProvider.html">StorageProvider</a></li></ul><h3>Interfaces</h3><ul><li><a href="IPlugin.html">IPlugin</a></li><li><a href="IStorageProvider.html">IStorageProvider</a></li></ul><h3>Mixins</h3><ul><li><a href="Guild.html">Guild</a></li><li><a href="Loggable.html">Loggable</a></li><li><a href="Message.html">Message</a></li></ul><h3>Modules</h3><ul><li><a href="module-CommandDecorators.html">CommandDecorators</a></li><li><a href="module-Lang.html">Lang</a></li><li><a href="module-ListenerUtil.html">ListenerUtil</a></li><li><a href="module-Middleware.html">Middleware</a></li><li><a href="module-Providers.html">Providers</a></li><li><a href="module-Time.html">Time</a></li><li><a href="module-Util.html">Util</a></li></ul><h3>Decorators</h3><ul><li><a href="global.html#deprecatedClass">deprecatedClass</a></li><li><a href="global.html#deprecatedMethod">deprecatedMethod</a></li><li><a href="global.html#logger">logger</a></li></ul><h3>TypeDefs</h3><ul><li><a href="global.html#ArgOpts">ArgOpts</a></li><li><a href="global.html#BaseResolverType">BaseResolverType</a></li><li><a href="global.html#BaseStrings">BaseStrings</a></li><li><a href="global.html#CommandInfo">CommandInfo</a></li><li><a href="global.html#DefaultGuildSettings">DefaultGuildSettings</a></li><li><a href="global.html#Difference">Difference</a></li><li><a href="global.html#LocalizedCommandInfo">LocalizedCommandInfo</a></li><li><a href="global.html#LogData">LogData</a></li><li><a href="global.html#LogLevel">LogLevel</a></li><li><a href="global.html#MiddlewareFunction">MiddlewareFunction</a></li><li><a href="global.html#PluginConstructor">PluginConstructor</a></li><li><a href="global.html#ResolverConstructor">ResolverConstructor</a></li><li><a href="global.html#ResourceLoader">ResourceLoader</a></li><li><a href="global.html#ResourceProxy">ResourceProxy</a></li><li><a href="global.html#RespondOptions">RespondOptions</a></li><li><a href="global.html#StorageProviderConstructor">StorageProviderConstructor</a></li><li><a href="global.html#TemplateData">TemplateData</a></li><li><a href="global.html#Transport">Transport</a></li><li><a href="global.html#TransportFunction">TransportFunction</a></li><li><a href="global.html#Tuple">Tuple</a></li><li><a href="global.html#YAMDBFOptions">YAMDBFOptions</a></li></ul><h3>Externals</h3><ul><li><a href="external-Client.html">Client</a></li><li><a href="external-ClientOptions.html">ClientOptions</a></li><li><a href="external-Collection.html">Collection</a></li><li><a href="external-Guild.html">Guild</a></li><li><a href="external-Message.html">Message</a></li><li><a href="external-MessageOptions.html">MessageOptions</a></li><li><a href="external-PermissionResolvable.html">PermissionResolvable</a></li><li><a href="external-Role.html">Role</a></li><li><a href="external-User.html">User</a></li></ul>
</nav>

<div id="main">
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable no-unused-expressions */
/* eslint-disable no-mixed-operators */
import { BaseCommandName } from '../types/BaseCommandName';
import { Client } from '../client/Client';
import { Command } from '../command/Command';
import { GuildStorage } from '../storage/GuildStorage';
import { Message } from '../types/Message';
import { Time } from './Time';

/**
 * Utility class containing handy static methods that can
 * be used anywhere
 * @module Util
 */
export class Util
{
	/**
	 * Tangible representation of all base command names
	 * @static
	 * @name baseCommandNames
	 * @type {BaseCommandName[]}
	 */
	public static baseCommandNames: BaseCommandName[] = require('./static/baseCommandNames.json');

	/**
	 * Return whether or not a command was called in the given
	 * message, the called command, the prefix used to call the
	 * command, and the name or alias of the command used to call it.
	 * >Returns everything it manages to determine up to the point of failure
	 * @static
	 * @method wasCommandCalled
	 * @param {Message} message Message to check
	 * @returns {Promise&lt;Tuple&lt;boolean, Command | null, string, string | null>>}
	 */
	public static async wasCommandCalled(message: Message): Promise&lt;[boolean, Command | null, string, string | null]>
	{
		const client: Client = message.client as Client;
		const dm: boolean = message.channel.type === 'dm';
		const prefixes: string[] = [
			`&lt;@${client.user!.id}>`,
			`&lt;@!${client.user!.id}>`
		];

		const guildStorage: GuildStorage | undefined | null = !dm
			? message.guild.storage || client.storage.guilds.get(message.guild.id)
			: null;

		if (!dm) prefixes.push(await guildStorage!.settings.get('prefix'));
		else prefixes.push(await client.storage.get('defaultGuildSettings.prefix'));

		let prefix: string | undefined = prefixes.find(a => message.content.trim().startsWith(a));
		if (dm &amp;&amp; typeof prefix === 'undefined') prefix = '';
		if (!dm &amp;&amp; typeof prefix === 'undefined') return [false, null, prefix!, null];

		const commandName: string = message.content.trim().slice(prefix!.length)
			.trim()
			.split(' ')[0];
		const command: Command | undefined = client.commands.resolve(commandName);
		if (!command) return [false, null, prefix!, commandName];
		if (command.disabled) return [false, command, prefix!, commandName];

		return [true, command, prefix!, commandName];
	}

	/**
	 * Split args from the input by the given Command's argument separator
	 * @static
	 * @method parseArgs
	 * @param {string} input Input string to parse args from
	 * @param {Command} [command] Command object, used to determine the args separator.
	 * 							  If none is given, `' '` will be used as the separator
	 * @returns {string[]}
	 */
	public static parseArgs(input: string, command?: Command): string[]
	{
		let delimiter: string | null = ' ';
		let output: string[];

		if (command &amp;&amp; command.argOpts)
		{
			if (typeof command.argOpts.separator === 'undefined') delimiter = ' ';
			else if (command.argOpts.separator === null) delimiter = null;
			else delimiter = command.argOpts.separator;
		}

		if (delimiter === null) output = [input];
		else if (delimiter === '') output = input.split(delimiter);
		else output = input
			.split(delimiter)
			.map(a => a.trim())
			.filter(a => a !== '');

		return output!;
	}

	/**
	 * Pads the right side of a string with spaces to the given length
	 * @static
	 * @method padRight
	 * @param {string} text Text to pad
	 * @param {number} length Length to pad to
	 * @returns {string}
	 */
	public static padRight(text: string, length: number): string
	{
		const pad: number = Math.max(0, Math.min(length, length - text.length));
		return `${text}${' '.repeat(pad)}`;
	}

	/**
	 * Returns the given string lowercased with any non
	 * alphanumeric chars removed
	 * @static
	 * @method normalize
	 * @param {string} text Text to normalize
	 * @returns {string}
	 */
	public static normalize(text: string): string
	{
		return text.toLowerCase().replace(/[^a-z0-9]+/g, '');
	}

	/**
	 * Returns the given string with special characters escaped
	 * @static
	 * @method escape
	 * @param {string} input String to escape
	 * @returns {string}
	 */
	public static escape(input: string): string
	{
		return input.replace(/[[\](){}|\\^$+\-*?.]/g, '\\$&amp;');
	}

	/**
	 * Assigns the given value along the given nested path within
	 * the provided initial object
	 * @static
	 * @method assignNestedValue
	 * @param {any} obj Object to assign to
	 * @param {string[]} path Nested path to follow within the object
	 * @param {any} value Value to assign within the object
	 * @returns {void}
	 */
	public static assignNestedValue(obj: any, path: string[], value: any): void
	{
		if (typeof obj !== 'object' || obj instanceof Array)
			throw new Error(`Initial input of type '${typeof obj}' is not valid for nested assignment`);

		if (path.length === 0)
			throw new Error('Missing nested assignment path');

		const first: string = path.shift()!;
		if (typeof obj[first] === 'undefined') obj[first] = {};
		if (path.length > 1 &amp;&amp; (typeof obj[first] !== 'object' || obj[first] instanceof Array))
			throw new Error(`Target '${first}' is not valid for nested assignment.`);

		if (path.length === 0) obj[first] = value;
		else Util.assignNestedValue(obj[first], path, value);
	}

	/**
	 * Remove a value from within an object along a nested path
	 * @static
	 * @method removeNestedValue
	 * @param {any} obj Object to remove from
	 * @param {string[]} path Nested path to follow within the object
	 * @returns {void}
	 */
	public static removeNestedValue(obj: any, path: string[]): void
	{
		if (typeof obj !== 'object' || obj instanceof Array) return;
		if (path.length === 0)
			throw new Error('Missing nested assignment path');

		const first: string = path.shift()!;
		if (typeof obj[first] === 'undefined') return;
		if (path.length > 1 &amp;&amp; (typeof obj[first] !== 'object' || obj[first] instanceof Array))
			return;

		if (path.length === 0) delete obj[first];
		else Util.removeNestedValue(obj[first], path);
	}

	/**
	 * Fetches a nested value from within an object via the
	 * provided path
	 * @static
	 * @method getNestedValue
	 * @param {any} obj Object to search
	 * @param {string[]} path Nested path to follow within the object
	 * @returns {any}
	 */
	public static getNestedValue(obj: any, path: string[]): any
	{
		if (typeof obj === 'undefined') return;
		if (path.length === 0) return obj;

		const first: string = path.shift()!;
		if (typeof obj[first] === 'undefined') return;
		if (path.length > 1 &amp;&amp; (typeof obj[first] !== 'object' || obj[first] instanceof Array))
			return;

		return Util.getNestedValue(obj[first], path);
	}

	/**
	 * Converts a TypeScript-style argument list into a valid args data object
	 * for [resolve]{@link module:Middleware.resolve} and [expect]{@link module:Middleware.expect}.
	 * This can help if the object syntax for resolving/expecting Command
	 * arguments is too awkward or cluttered, or if a simpler syntax is
	 * overall preferred.
	 *
	 * Args marked with `?` (for example: `arg?: String`) are declared as
	 * optional and will be converted to `'[arg]': 'String'` at runtime.
	 * Normal args will convert to `'&lt;arg>': 'String'`
	 *
	 * Example:
	 * ```
	 * `user: User, height: ['short', 'tall'], ...desc?: String`
	 * // becomes:
	 * { '&lt;user>': 'User', '&lt;height>': ['short', 'tall'], '[...desc]': 'String' }
	 * ```
	 * @static
	 * @method parseArgTypes
	 * @param {string} input Argument list string
	 * @returns {object}
	 */
	public static parseArgTypes(input: string): { [arg: string]: string | string[] }
	{
		const argStringRegex: RegExp = /(?:\.\.\.)?\w+\?? *: *(?:\[.*?\](?= *, *)|(?:\[.*?\] *$)|\w+)/g;
		if (!argStringRegex.test(input))
			throw new Error(`Input string is incorrectly formatted: ${input}`);

		const output: { [arg: string]: string | string[] } = {};
		const args: string[] = input.match(argStringRegex)!;
		for (let arg of args)
		{
			const split: string[] = arg.split(':').map(a => a.trim());
			let name: string = split.shift()!;
			arg = split.join(':');
			if (/(?:\.\.\.)?.+\?/.test(name)) name = `[${name.replace('?', '')}]`;
			else name = `&lt;${name}>`;

			if (/\[ *(?:(?: *, *)?(['"])(\S+)\1)+ *\]|\[ *\]/.test(arg))
			{
				const data: string = arg.match(/\[(.*)\]/)![1];
				if (!data) throw new Error('String literal array cannot be empty');
				const values: string[] = data
					.split(',')
					.map(a => a.trim().slice(1, -1));
				output[name] = values;
			}
			else output[name] = arg;
		}
		return output;
	}

	/**
	 * Parse a ratelimit Tuple from the given shorthand string
	 * @param {string} limitString Ratelimit string matching the regex `\d+\/\d+[s|m|h|d]`&lt;br>
	 * 						 	   **Example:** `1/10m` to limit a command to one use per 10 minutes
	 */
	public static parseRateLimit(limitString: string): [number, number]
	{
		const limitRegex: RegExp = /^(\d+)\/(\d+)(s|m|h|d)?$/;
		if (!limitRegex.test(limitString))
			throw new Error(`Failed to parse a ratelimit from '${limitString}'`);

		const parsedLimit: RegExpExecArray = limitRegex.exec(limitString)!;

		let [limit, duration]: [string | number, string | number] = parsedLimit.slice(1, 3) as [string, string];
		const [post]: [string] = parsedLimit.slice(3, 4) as [string];

		if (post) duration = Time.parseShorthand(duration + post)!;
		else duration = parseInt(duration);
		limit = parseInt(limit);

		return [limit, duration];
	}

	/**
	 * Implementation of `performance-now`
	 * @static
	 * @method now
	 * @returns {number}
	 */
	public static now(): number
	{
		type NSFunction = (hr?: [number, number]) => number;
		const ns: NSFunction = (hr = process.hrtime()) => hr[0] * 1e9 + hr[1];
		return (ns() - (ns() - process.uptime() * 1e9)) / 1e6;
	}

	/**
	 * Flatten an array that may contain nested arrays
	 * @static
	 * @method flattenArray
	 * @param {any[]} array
	 * @returns {any[]}
	 */
	public static flattenArray&lt;T>(array: (T | T[])[]): T[]
	{
		const result: T[] = [];
		for (const item of array)
			item instanceof Array
				? result.push(...Util.flattenArray(item))
				: result.push(item);
		return result;
	}

	/**
	 * Emit a deprecation warning message for the given target
	 * @static
	 * @method emitDeprecationWarning
	 * @param {any} target Deprecation target
	 * @param {string} message Deprecation message
	 * @returns {void}
	 */
	public static emitDeprecationWarning(target: any, message: string): void
	{
		if (typeof target._warnCache === 'undefined')
			Object.defineProperty(target, '_warnCache', { value: {} });

		const warnCache: { [key: string]: boolean } = target._warnCache;
		if (warnCache[message]) return;
		warnCache[message] = true;

		process.emitWarning(message, 'DeprecationWarning');
	}

	/**
	 * Attempts to lazy-load any of the given packages in order,
	 * returning the entire namespace of the first package to be
	 * loaded. Errors if no given package was found
	 * @returns {any} The first package namespace to be found
	 */
	public static lazyLoad&lt;T>(...packages: string[]): T
	{
		let pkg!: T;

		for (const p of packages)
		{
			try { pkg = require(p); }
			catch {}
			if (pkg) break;
		}

		if (!pkg) throw new Error(`Failed to lazy-load any of these packages: ${packages.join(', ')}`);

		return pkg;
	}
}
</code></pre>
        </article>
    </section>





</div>

<br class="clear">

<footer>
	<div align="right">
    	<a href="https://github.com/jsdoc3/jsdoc">JSDoc3.5.0-dev</a> | Minami
	</div>
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
