{"version":3,"sources":["storage/Database.ts"],"names":[],"mappings":";;;;;;;;AAAA,kDAAuD;AACvD,uCAAoC;AAGpC;;;;;;;;;;;;;;GAcG;AACH;IASC,YAAoB,GAAW,EAAE,KAAc;QAE9C,IAAI,QAAQ,CAAC,SAAS;YACrB,MAAM,IAAI,KAAK,CAAC,yFAAyF,CAAC,CAAC;QAE5G,QAAQ,CAAC,SAAS,GAAG,IAAI,CAAC;QAC1B,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;QAEhB,sBAAsB;QACtB,MAAM,QAAQ,GAAa,CAAC,sBAAsB,EAAE,WAAW,CAAC,CAAC;QACjE,MAAM,GAAG,GAA+B,WAAI,CAAC,QAAQ,CAAmB,GAAG,QAAQ,CAAC,CAAC,SAAS,CAAC;QAE/F,MAAM,OAAO,GACZ,CAAC,GAAG,IAAI,EAAE,EAAE,GAAG,IAAI,KAAK;YAAE,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAE5E;;;;WAIG;QACH,IAAI,CAAC,EAAE,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,OAAO,EAAE,CAAC,CAAC;IAC3C,CAAC;IAED;;;;;;;;;OASG;IACI,MAAM,KAAK,EAAE;QAEnB,OAAO,QAAQ,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC;IAC/B,CAAC;IAED;;;;;;;;;;;;;;;;OAgBG;IACI,MAAM,CAAC,QAAQ,CAAC,GAAY,EAAE,QAAiB,KAAK;QAE1D,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS;YAC9B,MAAM,IAAI,KAAK,CAAC,iEAAiE,CAAC,CAAC;QAEpF,IAAI,IAAI,CAAC,SAAS;YAAE,OAAO,IAAI,CAAC,SAAS,CAAC;QAC1C,OAAO,IAAI,QAAQ,CAAC,GAAI,EAAE,KAAK,CAAC,CAAC;IAClC,CAAC;IAED;;;;OAIG;IACI,KAAK,CAAC,IAAI;QAEhB,IAAI;YAAE,MAAM,IAAI,CAAC,EAAE,CAAC,YAAY,EAAE,CAAC;SAAE;QACrC,OAAO,GAAG,EACV;YACC,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,uCAAuC,GAAG,EAAE,CAAC,CAAC;YACvE,OAAO,CAAC,IAAI,EAAE,CAAC;SACf;IACF,CAAC;CACD;AApFA;IADC,eAAM,CAAC,UAAU,CAAC;yCACe;AAHnC,4BAuFC","file":"Database.js","sourcesContent":["import { Logger, logger } from '../util/logger/Logger';\nimport { Util } from '../util/Util';\nimport * as Sequelize from 'sequelize';\n\n/**\n * >**Note:** This won't do anything for you if you're not using\n * a `StorageProvider` for your client that uses Sequelize\n *\n * Holds the Sequelize connection to whichever database backend\n * is chosen via the Client StorageProvider. As long as you wait\n * until `clientReady` you can safely use {@link Database.instance}\n * to get the Database instance and access the Sequelize connection\n * via {@link Database#db}\n *\n * This will allow you to define and access your own Sequelize Models\n * without having to create another database connection. This is\n * especially important when using `SQLiteProvider` as SQLite\n * does not like having multiple connections to an sqlite file\n */\nexport class Database\n{\n\t@logger('Database')\n\tprivate readonly _logger!: Logger;\n\tprivate static _instance: Database;\n\tprivate _url: string;\n\n\tpublic db: Sequelize.Sequelize;\n\n\tprivate constructor(url: string, debug: boolean)\n\t{\n\t\tif (Database._instance)\n\t\t\tthrow new Error('Cannot create multiple instances of Database singleton. Use Database.instance() instead');\n\n\t\tDatabase._instance = this;\n\t\tthis._url = url;\n\n\t\t// Lazy load sequelize\n\t\tconst packages: string[] = ['sequelize-typescript', 'sequelize'];\n\t\tconst seq: typeof Sequelize.Sequelize = Util.lazyLoad<typeof Sequelize>(...packages).Sequelize;\n\n\t\tconst logging: (...args: any[]) => void =\n\t\t\t(...args) => { if (debug) this._logger.debug(args[0], ...args.slice(1)); };\n\n\t\t/**\n\t\t * The Sequelize connection to the database specified by\n\t\t * your chosen storage provider\n\t\t * @type {Sequelize}\n\t\t */\n\t\tthis.db = new seq(this._url, { logging });\n\t}\n\n\t/**\n\t * **(Static)** The Sequelize connection to the database\n\t * specified by your chosen storage provider.\n\t *\n\t * >**WARNING:** Accessing this before the client has created\n\t * the singleton instance will throw an error. To be safe,\n\t * wait until `clientReady` before accessing the Database\n\t * connection\n\t * @type {Sequelize}\n\t */\n\tpublic static get db(): Sequelize.Sequelize\n\t{\n\t\treturn Database.instance().db;\n\t}\n\n\t/**\n\t * As long as a Sequelize-using storage provider is being used,\n\t * this will return the Database instance holding the Sequelize\n\t * connection to the database.\n\t *\n\t * Parameters are not needed and will be passed internally by\n\t * the framework when the Database singleton is created before\n\t * `clientReady` is emitted.\n\t *\n\t * >**WARNING:** Accessing this before the client has created\n\t * the singleton instance will throw an error. To be safe,\n\t * wait until `clientReady` before accessing the Database\n\t * connection\n\t * @param {string} [url] The database connection url\n\t * @param {boolean} [debug=false] Whether or not to log Database debug info\n\t * @returns {Database}\n\t */\n\tpublic static instance(url?: string, debug: boolean = false): Database\n\t{\n\t\tif (!url && !Database._instance)\n\t\t\tthrow new Error('A database url is needed the first time a Database is accessed.');\n\n\t\tif (this._instance) return this._instance;\n\t\treturn new Database(url!, debug);\n\t}\n\n\t/**\n\t * Authenticate the connection to the database. This is called\n\t * internally by the framework\n\t * @returns {Promise<void>}\n\t */\n\tpublic async init(): Promise<void>\n\t{\n\t\ttry { await this.db.authenticate(); }\n\t\tcatch (err)\n\t\t{\n\t\t\tawait this._logger.error(`Failed to connect to the database:\\n${err}`);\n\t\t\tprocess.exit();\n\t\t}\n\t}\n}\n"],"sourceRoot":"../../src"}