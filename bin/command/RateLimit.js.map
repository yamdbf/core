{"version":3,"sources":["command/RateLimit.ts"],"names":[],"mappings":";;AAAA;;;;;GAKG;AACH;IASC,YAAmB,KAAuB;QAEzC;;;;WAIG;QACH,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAEtB;;;WAGG;QACH,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAEzB,IAAI,CAAC,MAAM,EAAE,CAAC;IACf,CAAC;IAED;;;OAGG;IACK,MAAM;QAEb,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;QACjB,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAChB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;IACxB,CAAC;IAED;;;;;OAKG;IACI,IAAI;QAEV,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAAC,IAAI,CAAC,MAAM,EAAE,CAAC;QAC7C,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QAC5C,IAAI,CAAC,MAAM,EAAE,CAAC;QACd,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC;YAAC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC;QACjE,MAAM,CAAC,IAAI,CAAC;IACb,CAAC;IAED;;;OAGG;IACH,IAAW,SAAS;QAEnB,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;IACnE,CAAC;IAED;;;;OAIG;IACH,IAAW,SAAS;QAEnB,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC;YAC7D,CAAC,CAAC,IAAI,CAAC,KAAK;YACZ,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;IAC7B,CAAC;IAED;;;;OAIG;IACH,IAAW,WAAW;QAErB,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC;IACvB,CAAC;IAED;;;;OAIG;IACI,WAAW;QAEjB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACvB,CAAC;CACD;AA7FD,8BA6FC","file":"RateLimit.js","sourcesContent":["/**\n * Maintains its own call count and expiry for making sure\n * things only happen a certain number of times within\n * a given timeframe\n * @param {Tuple<number, number>} limit Tuple containing quantity and duration\n */\nexport class RateLimit\n{\n\tprivate _count: number;\n\tprivate _notified: boolean;\n\n\tpublic readonly limit: number;\n\tpublic readonly duration: number;\n\tpublic expires: number;\n\n\tpublic constructor(limit: [number, number])\n\t{\n\t\t/**\n\t\t * The number of times this RateLimit can be\n\t\t * called within its duration\n\t\t * @type {number}\n\t\t */\n\t\tthis.limit = limit[0];\n\n\t\t/**\n\t\t * The time from first call until reset\n\t\t * @type {number}\n\t\t */\n\t\tthis.duration = limit[1];\n\n\t\tthis._reset();\n\t}\n\n\t/**\n\t * Sets this RateLimit to default values\n\t * @private\n\t */\n\tprivate _reset(): void\n\t{\n\t\tthis.expires = 0;\n\t\tthis._count = 0;\n\t\tthis._notified = false;\n\t}\n\n\t/**\n\t * Returns whether or not this rate limit has been capped out\n\t * for its current expiry window while incrementing calls\n\t * towards the rate limit cap if not currently capped\n\t * @returns {boolean}\n\t */\n\tpublic call(): boolean\n\t{\n\t\tif (this.expires < Date.now()) this._reset();\n\t\tif (this._count >= this.limit) return false;\n\t\tthis._count++;\n\t\tif (this._count === 1) this.expires = Date.now() + this.duration;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Return whether or not this ratelimit is currently capped out\n\t * @type {boolean}\n\t */\n\tpublic get isLimited(): boolean\n\t{\n\t\treturn (this._count >= this.limit) && (Date.now() < this.expires);\n\t}\n\n\t/**\n\t * The remaining number of uses this RateLimit has for\n\t * this expiry period\n\t * @type {number}\n\t */\n\tpublic get remaining(): number\n\t{\n\t\treturn (((this.limit - this._count) === 0) && !this.isLimited)\n\t\t\t? this.limit\n\t\t\t: this.limit - this._count;\n\t}\n\n\t/**\n\t * Whether or not this RateLimit was flagged after\n\t * notifying the user of being rate limited\n\t * @type {boolean}\n\t */\n\tpublic get wasNotified(): boolean\n\t{\n\t\treturn this._notified;\n\t}\n\n\t/**\n\t * Flag this RateLimit as having had the user the RateLimit\n\t * is for notified of being rate limited\n\t * @returns {void}\n\t */\n\tpublic setNotified(): void\n\t{\n\t\tthis._notified = true;\n\t}\n}\n"],"sourceRoot":"../../src"}