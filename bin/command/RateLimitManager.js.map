{"version":3,"sources":["command/RateLimitManager.ts"],"names":[],"mappings":";;AAAA,uCAAoC;AACpC,2CAAwC;AAIxC;;;;;GAKG;AACH;IAIC;QAEC,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;QACtB,WAAW,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,CAAC;IAC1D,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;OAyBG;IACI,GAAG,CAAC,KAAa,EAAE,GAAG,WAAqB;QAEjD,IAAI,SAAS,GAAc,WAAI,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,GAAG,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC;QAC1F,IAAI,SAAS;YAAE,OAAO,SAAS,CAAC;QAEhC,SAAS,GAAG,IAAI,qBAAS,CAAC,WAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;QACtD,WAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,GAAG,WAAW,EAAE,KAAK,CAAC,EAAE,SAAS,CAAC,CAAC;QAE7E,OAAO,SAAS,CAAC;IAClB,CAAC;IAED;;;;;;;;OAQG;IACI,IAAI,CAAC,KAAa,EAAE,GAAG,WAAqB;QAElD,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,WAAW,CAAC,CAAC,IAAI,EAAE,CAAC;IAC/C,CAAC;IAED;;;OAGG;IACK,KAAK,CAAC,QAAQ,CAAC,MAAuB;QAE7C,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACpC,IAAI,MAAM,CAAC,GAAG,CAAC,YAAY,qBAAS,EACpC;gBACC,MAAM,SAAS,GAAc,MAAM,CAAC,GAAG,CAAc,CAAC;gBACtD,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,QAAQ,GAAG,IAAI,CAAC;oBACjE,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;aACpB;iBACI,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC;gBAAE,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;;gBAC9D,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAoB,CAAC,CAAC;IACrD,CAAC;CACD;AA7ED,4CA6EC","file":"RateLimitManager.js","sourcesContent":["import { Util } from '../util/Util';\nimport { RateLimit } from './RateLimit';\n\ntype NestedRateLimit = { [descriptor: string]: NestedRateLimit | RateLimit };\n\n/**\n * Handles creation and retrieval of {@link RateLimit} objects for the given interval\n * and a given set of descriptors. Similar to {@link RateLimiter} but not designed around\n * Messages and Users. This simplifies the process of assigning ratelimits for any\n * arbitrary process/task\n */\nexport class RateLimitManager\n{\n\tprivate readonly _ratelimits: NestedRateLimit;\n\n\tpublic constructor()\n\t{\n\t\tthis._ratelimits = {};\n\t\tsetInterval(() => this._cleanup(this._ratelimits), 30e3);\n\t}\n\n\t/**\n\t * Get a {@link RateLimit} object for the given target descriptors. This can be\n\t * any arbitrary set of strings representing whatever you want. A good example\n\t * would be a RateLimit for a User within a Guild with 5 uses per minute:\n\t * ```\n\t * <RateLimitManager>.get('5/1m', guild.id, user.id);\n\t * ```\n\t * Or if you wanted to limit something in a DM for the specific User to 10\n\t * uses per 5 minutes:\n\t * ```\n\t * <RateLimitManager>.get('10/5m', user.id, 'DM');\n\t * ```\n\t * The possibilities are endless.<br><br>\n\t *\n\t * **Note:** The limit string counts as part of the descriptor. As such\n\t * ```\n\t * <RateLimitManager>.get('1/5m');\n\t * ```\n\t * is a valid descriptor, but keep in mind that every time you retrieve it, it\n\t * will be the same RateLimit instance, so if you need unique RateLimits for the\n\t * same limit/duration, you must create a unique descriptor\n\t * @param {string} limit Ratelimit string matching the regex `\\d+\\/\\d+[s|m|h|d]`<br>\n\t * \t\t\t\t\t\t **Example:** `1/10m` to create ratelimits of 1 per 10 minutes\n\t * @param {...string} descriptors RateLimit target descriptors\n\t * @returns {RateLimit}\n\t */\n\tpublic get(limit: string, ...descriptors: string[]): RateLimit\n\t{\n\t\tlet rateLimit: RateLimit = Util.getNestedValue(this._ratelimits, [...descriptors, limit]);\n\t\tif (rateLimit) return rateLimit;\n\n\t\trateLimit = new RateLimit(Util.parseRateLimit(limit));\n\t\tUtil.assignNestedValue(this._ratelimits, [...descriptors, limit], rateLimit);\n\n\t\treturn rateLimit;\n\t}\n\n\t/**\n\t * Return the result of the {@link RateLimit#call} for the given\n\t * descriptors. See {@link RateLimitManager#get} for details on\n\t * fetching RateLimits via descriptors\n\t * @param {string} limit Ratelimit string matching the regex `\\d+\\/\\d+[s|m|h|d]`<br>\n\t * \t\t\t\t\t\t **Example:** `1/10m` to create ratelimits of 1 per 10 minutes\n\t * @param {...string} descriptors RateLimit target descriptors\n\t * @returns {boolean}\n\t */\n\tpublic call(limit: string, ...descriptors: string[]): boolean\n\t{\n\t\treturn this.get(limit, ...descriptors).call();\n\t}\n\n\t/**\n\t * Recursively clean up expired ratelimits within the given target object\n\t * @private\n\t */\n\tprivate async _cleanup(target: NestedRateLimit): Promise<void>\n\t{\n\t\tfor (const key of Object.keys(target))\n\t\t\tif (target[key] instanceof RateLimit)\n\t\t\t{\n\t\t\t\tconst rateLimit: RateLimit = target[key] as RateLimit;\n\t\t\t\tif ((Date.now() - rateLimit.expires) > (rateLimit.duration + 10e3))\n\t\t\t\t\tdelete target[key];\n\t\t\t}\n\t\t\telse if (Object.keys(target[key]).length === 0) delete target[key];\n\t\t\telse this._cleanup(target[key] as NestedRateLimit);\n\t}\n}\n"],"sourceRoot":"../../src"}