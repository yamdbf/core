{"version":3,"sources":["command/middleware/Resolve.ts"],"names":[],"mappings":";;AAEA,0CAAuC;AAMvC,SAAgB,OAAO,CAAC,QAAgC;IAEvD,IAAI,OAAO,QAAQ,KAAK,QAAQ;QAAE,QAAQ;YACzC,WAAI,CAAC,aAAa,CAAC,QAAQ,CAAkB,CAAC;IAE/C,MAAM,KAAK,GAAa,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC9C,MAAM,KAAK,GAA0B,KAAK;SACxC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAE,QAA0B,CAAC,IAAI,CAAC,CAAC,CAAC;IAEjD,OAAO,KAAK,WAAyB,OAAgB,EAAE,IAAW;QAEjE,IAAI,YAAY,GAAY,KAAK,CAAC;QAClC,KAAK,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE,EACvC;YACC,IAAI,KAAK,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC;gBAAE,MAAM;YACpC,MAAM,IAAI,GAAW,KAAK,CAAC,KAAK,CAAC,CAAC;YAClC,IAAI,IAAI,GAAsB,KAAK,CAAC,KAAK,CAAC,CAAC;YAE3C,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EACxB;gBACC,IAAI,KAAK,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC;oBAAE,MAAM,IAAI,KAAK,CAC9C,cAAc,IAAI,2CAA2C,CAAC,CAAC;gBAEhE,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBAClC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;gBAClB,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;gBAChC,YAAY,GAAG,IAAI,CAAC;aACpB;YAED,IAAI,IAAI,YAAY,KAAK;gBAAE,IAAI,GAAG,QAAQ,CAAC;YAE3C,IAAI,IAAc,KAAK,KAAK;gBAAE,SAAS;YAEvC,MAAM,QAAQ,GAAa,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAC3D,IAAI,CAAC,QAAQ;gBACZ,MAAM,IAAI,KAAK,CAAC,YAAY,IAAI,cAAc,IAAI,kCAAkC,CAAC,CAAC;YAEvF,MAAM,KAAK,GAAQ,MAAM,QAAQ,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;YACpE,IAAI,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;YAEpB,IAAI,YAAY;gBAAE,MAAM;SACxB;QAED,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACxB,CAAC,CAAC;AACH,CAAC;AA7CD,0BA6CC","file":"Resolve.js","sourcesContent":["import { MiddlewareFunction } from '../../types/MiddlewareFunction';\nimport { Message } from '../../types/Message';\nimport { Util } from '../../util/Util';\nimport { Command } from '../Command';\nimport { Resolver } from '../resolvers/Resolver';\n\nexport type MappedArgType = { [arg: string]: string | string[] };\n\nexport function resolve(argTypes: string | MappedArgType): MiddlewareFunction\n{\n\tif (typeof argTypes === 'string') argTypes =\n\t\tUtil.parseArgTypes(argTypes) as MappedArgType;\n\n\tconst names: string[] = Object.keys(argTypes);\n\tconst types: (string | string[])[] = names\n\t\t.map(name => (argTypes as MappedArgType)[name]);\n\n\treturn async function(this: Command, message: Message, args: any[]): Promise<[Message, any[]]>\n\t{\n\t\tlet foundRestArg: boolean = false;\n\t\tfor (let [index, arg] of args.entries())\n\t\t{\n\t\t\tif (index > names.length - 1) break;\n\t\t\tconst name: string = names[index];\n\t\t\tlet type: string | string[] = types[index];\n\n\t\t\tif (name.includes('...'))\n\t\t\t{\n\t\t\t\tif (index !== names.length - 1) throw new Error(\n\t\t\t\t\t`Rest arg \\`${name}\\` must be the final argument descriptor.`);\n\n\t\t\t\targ = args.slice(index).join(' ');\n\t\t\t\targs[index] = arg;\n\t\t\t\targs = args.slice(0, index + 1);\n\t\t\t\tfoundRestArg = true;\n\t\t\t}\n\n\t\t\tif (type instanceof Array) type = 'String';\n\n\t\t\tif (type as string === 'Any') continue;\n\n\t\t\tconst resolver: Resolver = this.client.resolvers.get(type);\n\t\t\tif (!resolver)\n\t\t\t\tthrow new Error(`in arg \\`${name}\\`: Type \\`${type}\\` is not a valid argument type.`);\n\n\t\t\tconst value: any = await resolver.resolve(message, this, name, arg);\n\t\t\targs[index] = value;\n\n\t\t\tif (foundRestArg) break;\n\t\t}\n\n\t\treturn [message, args];\n\t};\n}\n"],"sourceRoot":"../../../src"}