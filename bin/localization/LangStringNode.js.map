{"version":3,"sources":["localization/LangStringNode.ts"],"names":[],"mappings":"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","file":"LangStringNode.js","sourcesContent":["import { CompiledTemplateScript } from './CompiledTemplateScript';\nimport { TemplateData } from '../types/TemplateData';\n\n/**\n * Represents a localization string parsed and compiled from a .lang file,\n * capable of validating arguments it expects at runtime\n * @private\n */\nexport class LangStringNode\n{\n\tpublic readonly lang: string;\n\tpublic readonly key: string;\n\tpublic readonly value: string;\n\tpublic readonly raw: string;\n\tpublic readonly scripts: CompiledTemplateScript[];\n\tpublic readonly args: { [key: string]: { isOptional: boolean, isArray: boolean, type: string } };\n\tpublic readonly argsValidator: ((args: TemplateData) => void) | undefined;\n\n\tprivate static readonly _argsDirective: RegExp = /^(##! *<[^>]+?>)/m;\n\tprivate static readonly _validArgsDirective: RegExp = /^##! *(?!< *, *)<(?:(?: *, *)?\\w+\\?? *: *\\w+(?:\\[\\])?)+>/m;\n\n\tprivate static readonly _argList: RegExp = /<([^>]+?)>/;\n\n\tprivate static readonly _allArgs: RegExp = /\\w+\\?? *: *\\w+(?:\\[\\])?/g;\n\tprivate static readonly _singleArg: RegExp = /(\\w+\\??) *: *(\\w+(?:\\[\\])?)/;\n\n\tprivate static readonly _validArgTypes: string[] = ['string', 'number', 'boolean', 'any'];\n\n\tpublic constructor(lang: string, key: string, value: string, raw: string, scripts: CompiledTemplateScript[])\n\t{\n\t\tthis.lang = lang;\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t\tthis.raw = raw;\n\t\tthis.scripts = scripts;\n\t\tthis.args = {};\n\n\t\t// Handle the args directive for this node if any\n\t\tif (LangStringNode._argsDirective.test(raw))\n\t\t{\n\t\t\t// Don't allow invalid args directives\n\t\t\tif (!LangStringNode._validArgsDirective.test(raw))\n\t\t\t\tthrow new TypeError(`in string \\`${lang}::${key}\\`: Malformed args directive`);\n\n\t\t\tconst directive: string = raw.match(LangStringNode._argsDirective)![1];\n\t\t\tconst argList: string = directive.match(LangStringNode._argList)![1];\n\t\t\tconst allArgs: string[] = argList.match(LangStringNode._allArgs)!;\n\n\t\t\t// Return whether or not the given type is an array type\n\t\t\tconst isArrayType: (type: string) => boolean = type => /\\w+\\[\\]/.test(type);\n\n\t\t\t// Return whether or not the given arg is optional\n\t\t\tconst isOptionalArg: (arg: string) => boolean = arg => /\\w+\\?/.test(arg);\n\n\t\t\t// Throw a type error if the given type is not valid\n\t\t\tconst validateType: (type: string, val: any, arg: string, array: boolean) => void =\n\t\t\t\t(type, val, arg, array) => {\n\t\t\t\t\tif (type === 'any') return;\n\t\t\t\t\tif (typeof val === type) return;\n\n\t\t\t\t\tthrow new TypeError([\n\t\t\t\t\t\t`String \\`${lang}::${key}\\`, ${array ? 'array ' : ''}arg \\`${arg}\\`:`,\n\t\t\t\t\t\t`Expected type \\`${type}\\`, got ${typeof val}`\n\t\t\t\t\t].join(' '));\n\t\t\t\t};\n\n\t\t\t// Process the lang string args directive and save the\n\t\t\t// argument type info for later use by the args validator\n\t\t\tfor (const arg of allArgs)\n\t\t\t{\n\t\t\t\tconst parsedArg: RegExpMatchArray = arg.match(LangStringNode._singleArg)!;\n\t\t\t\tconst argKey: string = parsedArg[1];\n\t\t\t\tconst argType: string = parsedArg[2];\n\t\t\t\tconst rawKey: string = isOptionalArg(argKey) ? argKey.slice(0, -1) : argKey;\n\t\t\t\tconst rawType: string = isArrayType(argType) ? argType.slice(0, -2) : argType;\n\n\t\t\t\tif (!LangStringNode._validArgTypes.includes(rawType))\n\t\t\t\t\tthrow new TypeError(`in string \\`${lang}::${key}\\`: Type \\`${argType}\\` is not a valid arg type`);\n\n\t\t\t\tthis.args[rawKey] = {\n\t\t\t\t\tisOptional: isOptionalArg(argKey),\n\t\t\t\t\tisArray: isArrayType(argType),\n\t\t\t\t\ttype: rawType\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Create and assign the args validator for this node\n\t\t\tthis.argsValidator = args => {\n\t\t\t\tfor (const argKey in this.args)\n\t\t\t\t{\n\t\t\t\t\tconst arg: { isOptional: boolean, isArray: boolean, type: string } = this.args[argKey];\n\t\t\t\t\tconst expectedType: string = `${arg.type}${arg.isArray ? '[]' : ''}`;\n\n\t\t\t\t\t// Allow undefined values if the arg is optional, otherwise error\n\t\t\t\t\tif (arg.isOptional && typeof args[argKey] === 'undefined') continue;\n\t\t\t\t\tif (typeof args[argKey] === 'undefined')\n\t\t\t\t\t\tthrow new TypeError([\n\t\t\t\t\t\t\t`String \\`${lang}::${key}\\`, arg \\`${argKey}\\`:`,\n\t\t\t\t\t\t\t`Expected type \\`${expectedType}\\`, got undefined`\n\t\t\t\t\t\t].join(' '));\n\n\t\t\t\t\t// Handle array types\n\t\t\t\t\tif (arg.isArray)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Array.isArray(args[argKey]))\n\t\t\t\t\t\t\tthrow new TypeError(`String \\`${lang}::${key}\\`, arg \\`${argKey}\\`: Expected Array`);\n\n\t\t\t\t\t\t// Validate the type of all values within the array given for array types\n\t\t\t\t\t\tfor (const val of args[argKey] as Array<any>)\n\t\t\t\t\t\t\tvalidateType(arg.type, val, argKey, true);\n\t\t\t\t\t}\n\t\t\t\t\telse validateType(arg.type, args[argKey], argKey, false);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n}\n"],"sourceRoot":"../../src"}