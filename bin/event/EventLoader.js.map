{"version":3,"sources":["event/EventLoader.ts"],"names":[],"mappings":";;;;;;;;AAAA,6BAA6B;AAC7B,6BAA6B;AAC7B,mCAAgC;AAChC,uCAAoC;AAEpC,mDAAgD;AAChD,kDAAuD;AAEvD;;;GAGG;AACH;IAQC,YAAmB,MAAc;QAEhC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;QACnB,IAAI,CAAC,SAAS,GAAG,IAAI,6BAAa,CAAC,MAAM,CAAC,CAAC;IAC5C,CAAC;IAED;;;;;OAKG;IACI,YAAY,CAAC,GAAW;QAE9B,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACtC,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,WAAW,CAAC;YAAE,OAAO;QAChD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IACjC,CAAC;IAED;;;OAGG;IACI,UAAU;QAEhB,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;IACjC,CAAC;IAED;;;OAGG;IACI,eAAe;QAErB,IAAI,CAAC,YAAY,EAAE,CAAC;QAEpB,IAAI,YAAY,GAAW,CAAC,CAAC;QAC7B,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ;YACjC,YAAY,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QAE9C,OAAO,YAAY,CAAC;IACrB,CAAC;IAED;;;OAGG;IACK,YAAY;QAEnB,IAAI,CAAC,SAAS,CAAC,qBAAqB,EAAE,CAAC;IACxC,CAAC;IAED;;;OAGG;IACK,eAAe,CAAC,GAAW;QAElC,iDAAiD;QACjD,IAAI,UAAU,GAAa,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,UAAU,CAAC,CAAC;QAEvD,+CAA+C;QAC/C,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EACvB;YACC,UAAU,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,eAAe,CAAC,CAAC,CAAC;YACrD,MAAM,kBAAkB,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;gBAChD,MAAM,IAAI,GAAW,CAAC,CAAC,KAAK,CAAC,sBAAsB,CAAE,CAAC,CAAC,CAAC,CAAC;gBACzD,IAAI,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC;oBAAE,OAAO,IAAI,CAAC;gBACnC,IAAI,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC;oBACpB,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,QAAQ,CAAC,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC;YAC3D,CAAC,CAAC,CAAC;YACH,UAAU,GAAG,kBAAkB,CAAC;SAChC;QAED,MAAM,YAAY,GAAY,EAAE,CAAC;QACjC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,sBAAsB,GAAG,EAAE,CAAC,CAAC;QAEhD,0DAA0D;QAC1D,KAAK,MAAM,IAAI,IAAI,UAAU,EAC7B;YACC,iDAAiD;YACjD,OAAO,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;YAE5C,MAAM,UAAU,GAAQ,OAAO,CAAC,IAAI,CAAC,CAAC;YACtC,MAAM,YAAY,GAAwB,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;YAE7E,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAC7B;gBACC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,uCAAuC,IAAI,EAAE,CAAC,CAAC;gBACjE,SAAS;aACT;YAED,KAAK,MAAM,UAAU,IAAI,YAAY,EACrC;gBACC,MAAM,aAAa,GAAU,IAAI,UAAU,EAAE,CAAC;gBAE9C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,mCAAmC,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC;gBAC3E,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;aACjC;SACD;QAED,oCAAoC;QACpC,KAAK,MAAM,KAAK,IAAI,YAAY,EAChC;YACC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAC9B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;SAC/B;QAED,OAAO,YAAY,CAAC,MAAM,CAAC;IAC5B,CAAC;IAED;;;OAGG;IACK,iBAAiB,CAAC,GAAQ;QAEjC,MAAM,YAAY,GAAgD,EAAE,CAAC;QACrE,MAAM,IAAI,GAAa,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACxC,IAAI,aAAK,CAAC,SAAS,CAAC,aAAa,CAAC,GAAG,CAAC,SAAS,CAAC;YAC/C,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;aAEnB,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC;YACvB,KAAK,MAAM,GAAG,IAAI,IAAI;gBACrB,IAAI,aAAK,CAAC,SAAS,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC;oBACpD,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAEvD,OAAO,WAAI,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;IACxC,CAAC;CACD;AAvIA;IADC,eAAM,CAAC,aAAa,CAAC;4CACY;AAHnC,kCA0IC","file":"EventLoader.js","sourcesContent":["import * as glob from 'glob';\nimport * as path from 'path';\nimport { Event } from './Event';\nimport { Util } from '../util/Util';\nimport { Client } from '../client/Client';\nimport { EventRegistry } from './EventRegistry';\nimport { logger, Logger } from '../util/logger/Logger';\n\n/**\n * Handles loading and registering Event class event handlers from\n * registered source directories.\n */\nexport class EventLoader\n{\n\t@logger('EventLoader')\n\tprivate readonly _logger!: Logger;\n\tprivate readonly _client: Client;\n\tprivate readonly _sources: string[];\n\tprivate readonly _registry: EventRegistry;\n\n\tpublic constructor(client: Client)\n\t{\n\t\tthis._client = client;\n\t\tthis._sources = [];\n\t\tthis._registry = new EventRegistry(client);\n\t}\n\n\t/**\n\t * Registers a source directory to load Event class event handlers from.\n\t * Does nothing if the directory is already registered. Events will be loaded\n\t * by the Client after the `continue` event is emitted at runtime\n\t * @returns {void}\n\t */\n\tpublic addSourceDir(dir: string): void\n\t{\n\t\tconst resolvedDir = path.resolve(dir);\n\t\tif (this._sources.includes(resolvedDir)) return;\n\t\tthis._sources.push(resolvedDir);\n\t}\n\n\t/**\n\t * Returns whether or not the EventLoader has any registered source directories\n\t * @returns {boolean}\n\t */\n\tpublic hasSources(): boolean\n\t{\n\t\treturn this._sources.length > 0;\n\t}\n\n\t/**\n\t * Loads or reloads all Events from all registered sources. Allows for hot-reloading\n\t * @returns {number} The total number of loaded or reloaded events\n\t */\n\tpublic loadFromSources(): number\n\t{\n\t\tthis._clearEvents();\n\n\t\tlet loadedEvents: number = 0;\n\t\tfor (const source of this._sources)\n\t\t\tloadedEvents += this._loadEventsFrom(source);\n\n\t\treturn loadedEvents;\n\t}\n\n\t/**\n\t * Unregisters and clears all loaded Event class event handlers\n\t * @private\n\t */\n\tprivate _clearEvents(): void\n\t{\n\t\tthis._registry.clearRegisteredEvents();\n\t}\n\n\t/**\n\t * Load events from the given directory\n\t * @private\n\t */\n\tprivate _loadEventsFrom(dir: string): number\n\t{\n\t\t// Glob all the javascript files in the directory\n\t\tlet eventFiles: string[] = glob.sync(`${dir}/**/*.js`);\n\n\t\t// Glob typescript files if `tsNode` is enabled\n\t\tif (this._client.tsNode)\n\t\t{\n\t\t\teventFiles.push(...glob.sync(`${dir}/**/!(*.d).ts`));\n\t\t\tconst filteredEventFiles = eventFiles.filter(f => {\n\t\t\t\tconst file: string = f.match(/\\/([^\\/]+?)\\.[j|t]s$/)![1];\n\t\t\t\tif (f.endsWith('.ts')) return true;\n\t\t\t\tif (f.endsWith('.js'))\n\t\t\t\t\treturn !eventFiles.find(cf => cf.endsWith(`${file}.ts`));\n\t\t\t});\n\t\t\teventFiles = filteredEventFiles;\n\t\t}\n\n\t\tconst loadedEvents: Event[] = [];\n\t\tthis._logger.debug(`Loading events in: ${dir}`);\n\n\t\t// Load and instantiate every event from the globbed files\n\t\tfor (const file of eventFiles)\n\t\t{\n\t\t\t// Delete the cached event file for hot-reloading\n\t\t\tdelete require.cache[require.resolve(file)];\n\n\t\t\tconst loadedFile: any = require(file);\n\t\t\tconst eventClasses: (new () => Event)[] = this._findEventClasses(loadedFile);\n\n\t\t\tif (eventClasses.length === 0)\n\t\t\t{\n\t\t\t\tthis._logger.warn(`Failed to find Event class in file: ${file}`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const eventClass of eventClasses)\n\t\t\t{\n\t\t\t\tconst eventInstance: Event = new eventClass();\n\n\t\t\t\tthis._logger.info(`Loaded Event handler for event: ${eventInstance.name}`);\n\t\t\t\tloadedEvents.push(eventInstance);\n\t\t\t}\n\t\t}\n\n\t\t// Register all of the loaded events\n\t\tfor (const event of loadedEvents)\n\t\t{\n\t\t\tevent._register(this._client);\n\t\t\tthis._registry.register(event);\n\t\t}\n\n\t\treturn loadedEvents.length;\n\t}\n\n\t/**\n\t * Recursively search for Event classes within the given object\n\t * @private\n\t */\n\tprivate _findEventClasses(obj: any): (new () => Event)[]\n\t{\n\t\tconst foundClasses: ((new () => Event) | (new () => Event)[])[] = [];\n\t\tconst keys: string[] = Object.keys(obj);\n\t\tif (Event.prototype.isPrototypeOf(obj.prototype))\n\t\t\tfoundClasses.push(obj);\n\n\t\telse if (keys.length > 0)\n\t\t\tfor (const key of keys)\n\t\t\t\tif (Event.prototype.isPrototypeOf(obj[key].prototype))\n\t\t\t\t\tfoundClasses.push(this._findEventClasses(obj[key]));\n\n\t\treturn Util.flattenArray(foundClasses);\n\t}\n}\n"],"sourceRoot":"../../src"}